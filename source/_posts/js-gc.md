---
title: javascript的gc机制
date: 2019-01-07 09:47:27
tags: js
---

> js会自动找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为实时的话开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行

## 生命周期
- 变量作用域链
    - 作用域：作用域就是变量和函数的可访问范围，
        - 全局作用域
        - 局部作用域
    - 函数作用域
    - 块级作用域
    - 执行环境
- 内存泄露
- 内存管理

## 标记清除
- 当变量进入执行环境时，垃圾回收器会将其标记为"进入环境"
- 当变量离开执行环境是，垃圾回收器会将其标记为"离开环境"
- 在运行的时候给存贮在内存的所有变量加上标记
- 然后去掉环境中的变量及被环境中变量引用的变量（闭包）的标记
- 回收带有标记的变量

## 引用记次
- 目前是低版本IE在使用该垃圾回收机制，所以才说IE我能怎么办
- 跟踪记录每个变量使用的次数
- 声明一个变量并赋值的时候这个值的引用次数加1
- 如果变量值变成另外一个，则这个值得引用次数减1
- 当引用次数为0的时候，说明没有变量在使用该值，则可以回收
- 问题
    - 如果变量的值被循环使用的时候，这个值就一直都是大于0，不能被回收
    ``` javaScript
        function fun() {
            var a = {};
            var b = {};
            a.test = b;
            b.test = a; // 引用之后都是引用次数都是2，离开运行环境的时候也不会被回收
        }
        // 常用例子，开发中遇到的问题
        var dom = document.getElementById('test');
        dom.onclick = function handle() {
            /* dom.onclick引用一次加1， dom就变成了一个Object
             * 此处会一直为1，造成内存泄露
             */
            /* code */
        }
        // 处理办法就是手动回收
        dom = null;
    ```

## 闭包
- 可以访问其他函数作用域的函数
- 其他函数被回收后，闭包并未销毁，也不会回收其他函数的局部变量，所以要手动回收
